% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/quantile_forest.R
\name{quantile_forest}
\alias{quantile_forest}
\title{Quantile forest}
\usage{
quantile_forest(
  X,
  Y,
  num.trees = 2000,
  quantiles = c(0.1, 0.5, 0.9),
  regression.splitting = FALSE,
  clusters = NULL,
  equalize.cluster.weights = FALSE,
  sample.fraction = 0.5,
  mtry = min(ceiling(sqrt(ncol(X)) + 20), ncol(X)),
  min.node.size = 5,
  honesty = TRUE,
  honesty.fraction = 0.5,
  honesty.prune.leaves = TRUE,
  nonlapping.block.size = 2,
  alpha = 0.05,
  imbalance.penalty = 0,
  compute.oob.predictions = FALSE,
  num.threads = NULL,
  seed = runif(1, 0, .Machine$integer.max),
  honesty.method = 4
)
}
\arguments{
\item{X}{The covariates used in the quantile regression.}

\item{Y}{The outcome.}

\item{num.trees}{Number of trees grown in the forest. Note: Getting accurate
confidence intervals generally requires more trees than
getting accurate predictions. Default is 2000.}

\item{quantiles}{Vector of quantiles used to calibrate the forest. Default is (0.1, 0.5, 0.9).}

\item{regression.splitting}{Whether to use regression splits when growing trees instead
of specialized splits based on the quantiles (the default).
Setting this flag to true corresponds to the approach to
quantile forests from Meinshausen (2006). Default is FALSE.}

\item{clusters}{Vector of integers or factors specifying which cluster each observation corresponds to.
Default is NULL (ignored).}

\item{equalize.cluster.weights}{If FALSE, each unit is given the same weight (so that bigger
clusters get more weight). If TRUE, each cluster is given equal weight in the forest. In this case,
during training, each tree uses the same number of observations from each drawn cluster: If the
smallest cluster has K units, then when we sample a cluster during training, we only give a random
K elements of the cluster to the tree-growing procedure. When estimating average treatment effects,
each observation is given weight 1/cluster size, so that the total weight of each cluster is the
same.}

\item{sample.fraction}{Fraction of the data used to build each tree.
Note: If honesty = TRUE, these subsamples will
further be cut by a factor of honesty.fraction. Default is 0.5.}

\item{mtry}{Number of variables tried for each split. Default is
\eqn{\sqrt p + 20} where p is the number of variables.}

\item{min.node.size}{A target for the minimum number of observations in each tree leaf. Note that nodes
with size smaller than min.node.size can occur, as in the original randomForest package.
Default is 5.}

\item{honesty}{Whether to use honest splitting (i.e., sub-sample splitting). Default is TRUE.
For a detailed description of honesty, honesty.fraction, honesty.prune.leaves, and recommendations for
parameter tuning, see the grf algorithm reference.}

\item{honesty.fraction}{The fraction of data that will be used for determining splits if honesty = TRUE. Corresponds
to set J1 in the notation of the paper. Default is 0.5 (i.e. half of the data is used for
determining splits).}

\item{honesty.prune.leaves}{If TRUE, prunes the estimation sample tree such that no leaves
are empty. If FALSE, keep the same tree as determined in the splits sample (if an empty leave is encountered, that
tree is skipped and does not contribute to the estimate). Setting this to FALSE may improve performance on
small/marginally powered data, but requires more trees (note: tuning does not adjust the number of trees).
Only applies if honesty is enabled. Default is TRUE.}

\item{nonlapping.block.size}{Specifies how to determine the number of blocks and the size of each block based on a given parameter \code{nonlapping_block_size}:
  \enumerate{
    \item \strong{Number of Blocks:} The total number of blocks is calculated as \eqn{n^{1/\text{nonlapping\_block\_size}}}. This formula ensures that the data is partitioned into several blocks based on the \code{nonlapping_block_size}.
    \item \strong{Size of Each Block:} Once the number of blocks is determined, the size of each block is then calculated as \eqn{n^{(\text{nonlapping\_block\_size}-1)/\text{nonlapping\_block\_size}}}. This is derived by dividing the total number of elements \eqn{n} by the number of blocks, leading to:
    \deqn{\frac{n}{n^{1/\text{nonlapping\_block\_size}}} = n^{1 - 1/\text{nonlapping\_block\_size}} = n^{(\text{nonlapping\_block\_size}-1)/\text{nonlapping\_block\_size}}}
  }
}

\item{alpha}{A tuning parameter that controls the maximum imbalance of a split. Default is 0.05.}

\item{imbalance.penalty}{A tuning parameter that controls how harshly imbalanced splits are penalized. Default is 0.}

\item{compute.oob.predictions}{Whether OOB predictions on training set should be precomputed. Default is FALSE.}

\item{num.threads}{Number of threads used in training. By default, the number of threads is set
to the maximum hardware concurrency.}

\item{seed}{The seed of the C++ random number generator.}

\item{honesty.method}{Specifies the method of honesty tree splitting, default is 4.
  \enumerate{
    \item \strong{0: Random sample.} The splitting is based on a random sample of the data.
    \item \strong{1: Sequential order.} The splitting is done in the order of the previous and the next data points.
    \item \strong{2: Block half-by-half.} Training occurs in the first half of the block and prediction in the second half.
    \item \strong{3: Random time-series window.} The splitting is based on a randomly chosen window within the time series.
    \item \strong{4: Random block sample.} A random sample is taken from each block for the splitting process.
  }
}

}
\value{
A trained quantile forest object.
}
\description{
Trains a regression forest that can be used to estimate
quantiles of the conditional distribution of Y given X = x.
}
\examples{
\donttest{
# Generate data.
n <- 50
p <- 10
X <- matrix(rnorm(n * p), n, p)
X.test <- matrix(0, 101, p)
X.test[, 1] <- seq(-2, 2, length.out = 101)
Y <- X[, 1] * rnorm(n)

# Train a quantile forest.
q.forest <- quantile_forest(X, Y, quantiles = c(0.1, 0.5, 0.9))

# Make predictions.
q.hat <- predict(q.forest, X.test)

# Make predictions for different quantiles than those used in training.
q.hat <- predict(q.forest, X.test, quantiles = c(0.1, 0.9))

# Train a quantile forest using regression splitting instead of quantile-based
# splits, emulating the approach in Meinshausen (2006).
meins.forest <- quantile_forest(X, Y, regression.splitting = TRUE)

# Make predictions for the desired quantiles.
q.hat <- predict(meins.forest, X.test, quantiles = c(0.1, 0.5, 0.9))
}

}
\references{
Athey, Susan, Julie Tibshirani, and Stefan Wager. "Generalized Random Forests".
 Annals of Statistics, 47(2), 2019.
}
